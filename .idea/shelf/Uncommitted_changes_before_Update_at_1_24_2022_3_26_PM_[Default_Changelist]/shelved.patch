Index: DeviceServers/ANDOR_CCD/add_ds_ANDOR_CCD.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from tango import DbDevInfo, Database\r\n\r\ndb = Database()\r\n\r\nnames = {7428: ['manip/CR', 'ANDOR_CCD_V0', 'ANDOR_CCD1', 7428,\r\n                {'Acquisition_Controls': {'SetAcquisitionMode': 3, 'SetTriggerMode': 1, 'SetFastExtTrigger': False,\r\n                                              'SetReadMode': 1, 'SetMultiTrack': (2, 128, 0), 'SetExposureTime': 0.0001,\r\n                                              'SetHSSpeed': 1, 'SetVSSpeed': 1, 'SetADChannel': 1, 'SetPreAmpGain': 0,\r\n                                              'SetBaselineClamp': True, 'SetTemperature': -80, 'CoolerON': True\r\n                                              }}\r\n                ]\r\n         }\r\n\r\n\r\n\r\ndef main():\r\n    i = 1\r\n    for dev_id, val in names.items():\r\n        dev_info = DbDevInfo()\r\n        dev_name = f'{val[0]}/{val[2]}'\r\n        dev_info.name = dev_name\r\n        dev_info._class = 'DS_ANDOR_CCD'\r\n        dev_info.server = f'DS_ANDOR_CCD/{i}_{val[2]}'\r\n        db.add_device(dev_info)\r\n        db.put_device_property(dev_name, {'device_id': dev_id, 'friendly_name': val[1], 'server_id': i,\r\n                                          'serial_number': val[3], 'parameters': str(val[4])})\r\n        i += 1\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DeviceServers/ANDOR_CCD/add_ds_ANDOR_CCD.py b/DeviceServers/ANDOR_CCD/add_ds_ANDOR_CCD.py
--- a/DeviceServers/ANDOR_CCD/add_ds_ANDOR_CCD.py	(revision 10c0b59783286c06f8b8b081886d20398573f89c)
+++ b/DeviceServers/ANDOR_CCD/add_ds_ANDOR_CCD.py	(date 1643032943905)
@@ -5,7 +5,7 @@
 names = {7428: ['manip/CR', 'ANDOR_CCD_V0', 'ANDOR_CCD1', 7428,
                 {'Acquisition_Controls': {'SetAcquisitionMode': 3, 'SetTriggerMode': 1, 'SetFastExtTrigger': False,
                                               'SetReadMode': 1, 'SetMultiTrack': (2, 128, 0), 'SetExposureTime': 0.0001,
-                                              'SetHSSpeed': 1, 'SetVSSpeed': 1, 'SetADChannel': 1, 'SetPreAmpGain': 0,
+                                              'SetHSSpeed': (0, 1), 'SetVSSpeed': 1, 'SetADChannel': 1, 'SetPreAmpGain': 0,
                                               'SetBaselineClamp': True, 'SetTemperature': -80, 'CoolerON': True
                                               }}
                 ]
Index: DeviceServers/ANDOR_CCD/DS_ANDOR_CCD.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/python3 -u\r\n# -*- coding: utf-8 -*-\r\nimport os\r\nimport sys\r\nfrom pathlib import Path\r\napp_folder = Path(__file__).resolve().parents[2]\r\nsys.path.append(str(app_folder))\r\n\r\nfrom typing import Tuple, Union\r\nimport ctypes\r\n\r\n\r\nimport numpy as np\r\nfrom DeviceServers.General.DS_Camera import DS_CAMERA_CCD\r\nfrom DeviceServers.General.DS_general import standard_str_output\r\nfrom collections import OrderedDict\r\n# -----------------------------\r\n\r\nfrom tango.server import device_property, command\r\nfrom tango import DevState\r\nfrom pypylon import pylon, genicam\r\n\r\n\r\n\r\nclass DS_ANDOR_CCD(DS_CAMERA_CCD):\r\n\r\n    polling_main = 5000\r\n    polling_infinite = 100000\r\n    timeoutt = 5000\r\n\r\n    dll_path= device_property(dtype=str)\r\n\r\n    def get_camera_friendly_name(self):\r\n        return self.camera.DeviceUserID.GetValue()\r\n\r\n    def set_camera_friendly_name(self, value):\r\n        self.friendly_name = str(value)\r\n        self.camera.DeviceUserID.SetValue(str(value))\r\n\r\n    def get_camera_serial_number(self) -> Union[str, int]:\r\n        return self.device.GetSerialNumber()\r\n\r\n    def get_camera_model_name(self) -> str:\r\n        return self.camera.GetDeviceInfo().GetModelName()\r\n\r\n    def get_exposure_time(self) -> float:\r\n        return self.camera.ExposureTimeAbs()\r\n\r\n    def set_exposure_time(self, value: float):\r\n        self.camera.ExposureTimeAbs.SetValue(value)\r\n\r\n    def set_trigger_delay(self, value: str):\r\n        self.camera.TriggerDelayAbs.SetValue(value)\r\n\r\n    def get_trigger_delay(self) -> str:\r\n        return self.camera.TriggerDelayAbs()\r\n\r\n    def get_exposure_min(self):\r\n        return self.camera.ExposureTimeAbs.Min\r\n\r\n    def get_exposure_max(self):\r\n        return self.camera.ExposureTimeAbs.Max\r\n\r\n    def set_gain(self, value: int):\r\n        self.camera.GainRaw.SetValue(value)\r\n\r\n    def get_gain(self) -> int:\r\n        return self.camera.GainRaw()\r\n\r\n    def get_gain_min(self) -> int:\r\n        return self.camera.GainRaw.Min\r\n\r\n    def get_gain_max(self) -> int:\r\n        return self.camera.GainRaw.Max\r\n\r\n    def get_width(self) -> int:\r\n        return self.camera.Width()\r\n\r\n    def set_width(self, value: int):\r\n        was_grabbing = False\r\n        if self.grabbing:\r\n            was_grabbing = True\r\n            self.stop_grabbing\r\n        self.camera.Width.SetValue(value)\r\n        if was_grabbing:\r\n            self.start_grabbing\r\n\r\n    def get_width_min(self):\r\n        return self.camera.Width.Min\r\n\r\n    def get_width_max(self):\r\n        return self.camera.Width.Max\r\n\r\n    def set_height(self, value: int):\r\n        was_grabbing = False\r\n        if self.grabbing:\r\n            was_grabbing = True\r\n            self.stop_grabbing\r\n        self.camera.Height.SetValue(value)\r\n        if was_grabbing:\r\n            self.start_grabbing\r\n\r\n    def get_height(self) -> int:\r\n        return self.camera.Height()\r\n\r\n    def get_height_min(self):\r\n        return self.camera.Height.Min\r\n\r\n    def get_height_max(self):\r\n        return self.camera.Height.Max\r\n\r\n    def get_offsetX(self) -> int:\r\n        return self.camera.OffsetX()\r\n\r\n    def set_offsetX(self, value: int):\r\n        self.camera.OffsetX = value\r\n\r\n    def get_offsetY(self) -> int:\r\n        return self.camera.OffsetY()\r\n\r\n    def set_offsetY(self, value: int):\r\n        self.camera.OffsetY = value\r\n\r\n    def set_format_pixel(self, value: str):\r\n        was_grabbing = False\r\n        if self.grabbing:\r\n            was_grabbing = True\r\n            self.stop_grabbing()\r\n        self.camera.PixelFormat = value\r\n        if was_grabbing:\r\n            self.start_grabbing()\r\n\r\n    def get_format_pixel(self) -> str:\r\n        return self.camera.PixelFormat()\r\n\r\n    def get_framerate(self):\r\n        return self.camera.ResultingFrameRateAbs()\r\n\r\n    def set_binning_horizontal(self, value: int):\r\n        self.camera.BinningHorizontal = value\r\n\r\n    def get_binning_horizontal(self) -> int:\r\n        return self.camera.BinningHorizontal()\r\n\r\n    def set_binning_vertical(self, value: int):\r\n        self.camera.BinningVertical = value\r\n\r\n    def get_binning_vertical(self) -> int:\r\n        return self.camera.BinningVertical()\r\n\r\n    def get_sensor_readout_mode(self) -> str:\r\n        return self.camera.SensorReadoutMode.GetValue()\r\n\r\n    def init_device(self):\r\n        self.pixel_format = None\r\n        self.camera: pylon.InstantCamera = None\r\n        self.converter: pylon.ImageFormatConverter = None\r\n        self.device = None\r\n        super().init_device()\r\n\r\n    def find_device(self) -> Tuple[int, str]:\r\n        state_ok = self.check_func_allowance(self.find_device)\r\n        argreturn = -1, b''\r\n        if state_ok:\r\n            self.device = self._get_camera_device()\r\n            if self.device is not None:\r\n                try:\r\n                    instance = pylon.TlFactory.GetInstance()\r\n                    self.camera = pylon.InstantCamera(instance.CreateDevice(self.device))\r\n                    self.turn_on_local()\r\n                    argreturn = 1, str(self.camera.GetDeviceInfo().GetSerialNumber()).encode('utf-8')\r\n                except Exception as e:\r\n                    self.error(f'Could not open camera. {e}')\r\n            else:\r\n                self.error(f'Could not find camera.')\r\n            self._device_id_internal, self._uri = argreturn\r\n            return argreturn\r\n\r\n    def turn_on_local(self) -> Union[int, str]:\r\n        if self.camera and not self.camera.IsOpen():\r\n            self.camera.Open()\r\n            self.converter = pylon.ImageFormatConverter()\r\n            self.set_state(DevState.ON)\r\n            self.get_camera_friendly_name()\r\n            self.info(f\"{self.device_name} was Opened.\", True)\r\n            return 0\r\n        else:\r\n            return f'Could not turn on camera it is opened already.' if self.camera else f'Could not turn on camera, ' \\\r\n                                                                                         f'because it does not exist.'\r\n\r\n    def turn_off_local(self) -> Union[int, str]:\r\n        if self.camera and self.camera.IsOpen():\r\n            if self.grabbing:\r\n                self.stop_grabbing()\r\n            self.camera.Close()\r\n            self.set_state(DevState.OFF)\r\n            self.info(f\"{self.device_name} was Closed.\", True)\r\n            return 0\r\n        else:\r\n            return f'Could not turn off camera it is closed already.' if not self.camera.IsOpen() \\\r\n                else f'Could not turn on camera, because it does not exist.'\r\n\r\n    def set_param_after_init_local(self) -> Union[int, str]:\r\n        functions = [self.set_transport_layer, self.set_analog_controls, self.set_aio_controls,\r\n                     self.set_acquisition_controls, self.set_image_format]\r\n        results = []\r\n        for func in functions:\r\n            results.append(func())\r\n        results_s = ''\r\n        for res in results:\r\n            if res != 0:\r\n                results_s = results_s + res\r\n        return results_s if results_s else 0\r\n\r\n    def set_acquisition_controls(self):\r\n        exposure_time = self.parameters['Acquisition_Controls']['ExposureTimeAbs']\r\n        trigger_mode = self.parameters['Acquisition_Controls']['TriggerMode']\r\n        trigger_delay = self.parameters['Acquisition_Controls']['TriggerDelayAbs']\r\n        frame_rate = self.parameters['Acquisition_Controls']['AcquisitionFrameRateAbs']\r\n        trigger_source = self.parameters['Acquisition_Controls']['TriggerSource']\r\n        formed_parameters_dict = {'TriggerSource': trigger_source, 'TriggerMode': trigger_mode,\r\n                                  'TriggerDelayAbs': trigger_delay, 'ExposureTimeAbs': exposure_time,\r\n                                  'AcquisitionFrameRateAbs': frame_rate, 'AcquisitionFrameRateEnable': True}\r\n        if trigger_mode == 'Trigger Software':\r\n            self.trigger_software = True\r\n        return self._set_parameters(formed_parameters_dict)\r\n\r\n    def set_transport_layer(self) -> Union[int, str]:\r\n        packet_size = self.parameters['Transport_layer']['Packet_size']\r\n        inter_packet_delay = self.parameters['Transport_layer']['Inter-Packet_Delay']\r\n        formed_parameters_dict = {'GevSCPSPacketSize': packet_size, 'GevSCPD': inter_packet_delay}\r\n        return self._set_parameters(formed_parameters_dict)\r\n\r\n    def set_analog_controls(self):\r\n        gain_mode = self.parameters['Analog_Controls']['GainAuto']\r\n        gain = self.parameters['Analog_Controls']['GainRaw']\r\n        blacklevel = self.parameters['Analog_Controls']['BlackLevelRaw']\r\n        balance_ratio = self.parameters['Analog_Controls']['BalanceRatioRaw']\r\n        formed_parameters_dict_analog_controls = {'GainAuto': gain_mode, 'GainRaw': gain, 'BlackLevelRaw': blacklevel,\r\n                                                  'BalanceRatioRaw': balance_ratio}\r\n        return self._set_parameters(formed_parameters_dict_analog_controls)\r\n\r\n    def set_aio_controls(self):\r\n        width = self.parameters['AOI_Controls']['Width']\r\n        height = self.parameters['AOI_Controls']['Height']\r\n        offset_x = self.parameters['AOI_Controls']['OffsetX']\r\n        offset_y = self.parameters['AOI_Controls']['OffsetY']\r\n        formed_parameters_dict_AOI = OrderedDict()\r\n        formed_parameters_dict_AOI['Width'] = width\r\n        formed_parameters_dict_AOI['Height'] = height\r\n        formed_parameters_dict_AOI['OffsetX'] = offset_x\r\n        formed_parameters_dict_AOI['OffsetY'] = offset_y\r\n        return self._set_parameters(formed_parameters_dict_AOI)\r\n\r\n    def set_image_format(self):\r\n        pixel_format = self.parameters['Image_Format_Control']['PixelFormat']\r\n        formed_parameters_dict_image_format = {'PixelFormat': pixel_format}\r\n        # to change, what if someone wants color converter\r\n        self.converter.OutputPixelFormat = pylon.PixelType_RGB16packed\r\n        # self.converter.OutputPixelFormat = pylon.PixelType_Mono8\r\n        self.converter.OutputBitAlignment = pylon.OutputBitAlignment_MsbAligned\r\n        return self._set_parameters(formed_parameters_dict_image_format)\r\n\r\n    def _set_parameters(self, formed_parameters_dict):\r\n        if self.camera.IsOpen():\r\n            if self.grabbing:\r\n                self.stop_grabbing()\r\n            try:\r\n                for param_name, param_value in formed_parameters_dict.items():\r\n                    setattr(self.camera, param_name, param_value)\r\n                return 0\r\n            except (genicam.GenericException, Exception) as e:\r\n                return f'Error appeared: {e} when setting parameter \"{param_name}\" for camera {self.device_name}.'\r\n        else:\r\n            return f'Basler_Camera {self.device_name} connected states {self.camera.IsOpen()} ' \\\r\n                   f'Camera grabbing status is {self.grabbing}.'\r\n\r\n    def _get_camera_device(self):\r\n        for device in pylon.TlFactory.GetInstance().EnumerateDevices():\r\n            if device.GetSerialNumber() == self.serial_number:\r\n                return device\r\n        return None\r\n\r\n    def get_image(self):\r\n        self.last_image = self.wait(self.timeoutt)\r\n\r\n    def wait(self, timeout):\r\n        if not self.grabbing:\r\n            self.start_grabbing()\r\n        try:\r\n            grabResult = self.camera.RetrieveResult(timeout, pylon.TimeoutHandling_ThrowException)\r\n            if grabResult.GrabSucceeded():\r\n                image = self.converter.Convert(grabResult)\r\n                grabResult.Release()\r\n                image = np.ndarray(buffer=image.GetBuffer(),\r\n                                   shape=(image.GetHeight(), image.GetWidth(), 3),\r\n                                   dtype=np.uint16)\r\n                # Convert 3D array to 2D for Tango to transfer it\r\n                image2D = image.transpose(2, 0, 1).reshape(-1, image.shape[1])\r\n                self.info('Image is received...')\r\n                return image2D\r\n            else:\r\n                raise pylon.GenericException\r\n        except (pylon.GenericException, pylon.TimeoutException) as e:\r\n            self.error(str(e))\r\n            return np.arange(300).reshape(10, 10, 3)\r\n\r\n    def get_controller_status_local(self) -> Union[int, str]:\r\n        r = 0\r\n        if self.camera.IsOpen():\r\n            self.set_status(DevState.ON)\r\n        else:\r\n            a = os.system('ping -c 1 -n 1 -w 1 ' + str(self.ip_address))\r\n            if a == 0:\r\n                self.set_status(DevState.OFF)\r\n            else:\r\n                self.set_status(DevState.FAULT)\r\n                r = f'{self.ip_address} is not reachable.'\r\n        return r\r\n\r\n    def start_grabbing_local(self):\r\n        if self.latestimage:\r\n            try:\r\n                self.info(\"Grabbing LatestImageOnly\", True)\r\n                self.camera.StartGrabbing(pylon.GrabStrategy_LatestImageOnly)\r\n                return 0\r\n            except Exception as e:\r\n                return str(e)\r\n        else:\r\n            try:\r\n                self.info(\"Grabbing OneByOne\", True)\r\n                self.camera.StartGrabbing(pylon.GrabStrategy_OneByOne)\r\n                return 0\r\n            except Exception as e:\r\n                return str(e)\r\n\r\n    def stop_grabbing_local(self):\r\n        try:\r\n            self.camera.StopGrabbing()\r\n            return 0\r\n        except Exception as e:\r\n            return str(e)\r\n\r\n    def grabbing_local(self):\r\n        if self.camera:\r\n            return self.camera.IsGrabbing()\r\n        else:\r\n            return False\r\n\r\n    @command(dtype_in=int, doc_in='state 1 or 0', dtype_out=str, doc_out=standard_str_output)\r\n    def set_trigger_mode(self, state):\r\n        state = 'On' if state else 'Off'\r\n        self.info(f'Enabling hardware trigger: {state}', True)\r\n        restart = False\r\n        if self.grabbing:\r\n            self.stop_grabbing()\r\n            restart = True\r\n        try:\r\n            print(self.camera)\r\n            self.camera.TriggerMode = state\r\n        except Exception as e:\r\n            self.error(e)\r\n            return str(e)\r\n        if restart:\r\n            self.start_grabbing()\r\n        return str(0)\r\n\r\n    # DLL functions\r\n\r\n\r\nclass Andor_test():\r\n\r\n    def __init__(self):\r\n        from pathlib import Path\r\n        self.dll_path = Path('C:/dev/pyconlyse/DeviceServers/ANDOR_CCD/atmcd32d.dll')\r\n        self.dll = self.load_dll()\r\n\r\n        self._Initialize()\r\n        func = [self._GetCameraSerialNumber(), self._SetAcquisitionMode(3), self._SetExposureTime(0.0001)]\r\n\r\n        results = []\r\n\r\n        for f in func:\r\n            results.append(f)\r\n\r\n        print(results)\r\n\r\n\r\n\r\n\r\n    \"\"\"\r\n    1) uint32_t Initialize(const CStr directory); DONE\r\n    2) uint32_t SetAcquisitionMode(int32_t mode); DONE\r\n    3) uint32_t SetExposureTime(float time); DONE\r\n    4) uint32_t SetHSSpeed(int32_t type, int32_t index); EM AMP 1\r\n    5) uint32_t SetVSSpeed(int32_t index); 1\r\n    6) uint32_t SetADChannel(int32_t channel); 1\r\n    7) uint32_t SetPreAmpGain(int32_t index); 0\r\n    8) uint32_t SetTriggerMode(int32_t mode); External\r\n    9) uint32_t SetFastExtTrigger(int32_t mode); False\r\n    10) uint32_t SetReadMode(int32_t mode); Multi-Track\r\n    11) uint32_t SetMultiTrack(int32_t number, int32_t height, int32_t offset, int32_t *bottom, int32_t *gap); 2 128, \r\n    12) uint32_t SetBaselineClamp(int32_t state); True\r\n    13) uint32_t SetTemperature(int32_t temperature); -80\r\n    14) uint32_t CoolerON(void );\r\n    \"\"\"\r\n\r\n    def load_dll(self):\r\n        dll = ctypes.WinDLL(str(self.dll_path))\r\n        return dll\r\n\r\n    def _Initialize(self, dir=\"\") -> Tuple[bool, str]:\r\n        dir_char = ctypes.c_char_p(dir.encode('utf-8'))\r\n        res = self.dll.Initialize(dir_char)\r\n        return True if res == 20002 else self._error(res)\r\n\r\n    def _GetCameraSerialNumber(self) -> Tuple[int, bool, str]:\r\n        serial_number = ctypes.c_int(0)\r\n        res = self.dll.GetCameraSerialNumber(ctypes.byref(serial_number))\r\n        serial_number = serial_number.value\r\n        return serial_number if res == 20002 else self._error(res)\r\n\r\n    def _SetAcquisitionMode(self, mode: int) -> Tuple[int, bool, str]:\r\n        \"\"\"\r\n        mode:\r\n            1 Single Scan\r\n            2 Accumulate\r\n            3 Kinetics\r\n            4 Fast Kinetics\r\n            5 Run till abort\r\n        \"\"\"\r\n        MODES = {1: 'Single Scan', 2: 'Accumulate', 3: 'Kinetics', 4: 'Fast Kinetics', 5: 'Run Till abort'}\r\n        if mode not in MODES:\r\n            return self._error(-1, user_def=f'Wrong mode {mode} for SetAcquisitionMode. MODES: {MODES}')\r\n        mode = ctypes.c_int(mode)\r\n        res = self.dll.SetAcquisitionMode(mode)\r\n        return True if res == 20002 else self._error(res)\r\n\r\n    def _SetExposureTime(self, exp_time: float) -> Tuple[bool, str]:\r\n        exp_time = ctypes.c_float(exp_time)\r\n        res = self.dll.SetExposureTime(exp_time)\r\n        return True if res == 20002 else self._error(res)\r\n\r\n    def _SetHSSpeed(self, typ: int, index: int) -> Tuple[bool, str]:\r\n        typ = ctypes.c_int(typ)\r\n        index = ctypes.c_int(index)\r\n        res = self.dll.SetHSSpeed(typ, index)\r\n        return True if res == 20002 else self._error(res)\r\n\r\n    def _error(self, code: int, user_def='') -> str:\r\n        \"\"\"\r\n        :param code: <=0\r\n        :param type: 0 for Connection error codes, 1 for Function error codes\r\n        :return: error as string\r\n        \"\"\"\r\n        errors = {20001: 'DRV_ERROR_CODES', 20002: 'DRV_SUCCESS', 20003: 'DRV_VXDNOTINSTALLED', 20004: 'DRV_ERROR_SCAN',\r\n                  20005: 'DRV_ERROR_CHECK_SUM', 20006: 'DRV_ERROR_FILELOAD', 20007: 'DRV_UNKNOWN_FUNCTION',\r\n                  20008: 'DRV_ERROR_VXD_INIT', 20009: 'DRV_ERROR_ADDRESS', 20010: 'DRV_ERROR_PAGELOCK',\r\n                  20011: 'DRV_ERROR_PAGE_UNLOCK', 20012: 'DRV_ERROR_BOARDTEST', 20013: 'DRV_ERROR_ACK',\r\n                  20014: 'DRV_ERROR_UP_FIFO', 20015: 'DRV_ERROR_PATTERN', 20017: 'DRV_ACQUISITION_ERRORS',\r\n                  20018: 'DRV_ACQ_BUFFER', 20019: 'DRV_ACQ_DOWNFIFO_FULL', 20020: 'DRV_PROG_UNKNOWN_INSTRUCTION',\r\n                  20021: 'DRV_ILLEGAL_OP_CODE', 20022: 'DRV_KINETIC_TIME_NOT_MET', 20023: 'DRV_ACCUM_TIME_NOT_MET',\r\n                  20024: 'DRV_NO_NEW_DATA', 20025: 'PCI_DMA_FAIL', 20026: 'DRV_SPOOLERROR',\r\n                  20027: 'DRV_SPOOLSETUPERROR', 20029: 'SATURATED', 20033: 'DRV_TEMPERATURE_CODES',\r\n                  20034: 'DRV_TEMPERATURE_OFF', 20035: 'DRV_TEMP_NOT_STABILIZED', 20036: 'DRV_TEMPERATURE_STABILIZED',\r\n                  20037: 'DRV_TEMPERATURE_NOT_REACHED', 20038: 'DRV_TEMPERATURE_OUT_RANGE',\r\n                  20039: 'DRV_TEMPERATURE_NOT_SUPPORTED', 20040: 'DRV_TEMPERATURE_DRIFT', 20049: 'DRV_GENERAL_ERRORS',\r\n                  20050: 'DRV_INVALID_AUX', 20051: 'DRV_COF_NOTLOADED', 20052: 'DRV_FPGAPROG', 20053: 'DRV_FLEXERROR',\r\n                  20054: 'DRV_GPIBERROR', 20055: 'ERROR_DMA_UPLOAD', 20064: 'DRV_DATATYPE', 20065: 'DRV_DRIVER_ERRORS',\r\n                  20066: 'DRV_P1INVALID', 20067: 'DRV_P2INVALID', 20068: 'DRV_P3INVALID', 20069: 'DRV_P4INVALID',\r\n                  20070: 'DRV_INIERROR', 20071: 'DRV_COFERROR', 20072: 'DRV_ACQUIRING', 20073: 'DRV_IDLE',\r\n                  20074: 'DRV_TEMPCYCLE', 20075: 'DRV_NOT_INITIALIZED', 20076: 'DRV_P5INVALID', 20077: 'DRV_P6INVALID',\r\n                  20078: 'DRV_INVALID_MODE', 20079: 'DRV_INVALID_FILTER', 20080: 'DRV_I2CERRORS',\r\n                  20081: 'DRV_DRV_I2CDEVNOTFOUND', 20082: 'DRV_I2CTIMEOUT', 20083: 'DRV_P7INVALID',\r\n                  20089: 'DRV_USBERROR', 20090: 'DRV_IOCERROR', 20091: 'DRV_VRMVERSIONERROR',\r\n                  20093: 'DRV_USB_INTERRUPT_ENDPOINT_ERROR', 20094: 'DRV_RANDOM_TRACK_ERROR',\r\n                  20095: 'DRV_INVALID_TRIGGER_MODE', 20096: 'DRV_LOAD_FIRMWARE_ERROR',\r\n                  20097: 'DRV_DIVIDE_BY_ZERO_ERROR', 20098: 'DRV_INVALID_RINGEXPOSURES', 20099: 'DRV_BINNING_ERROR',\r\n                  20990: 'DRV_ERROR_NOCAMERA', 20991: 'DRV_NOT_SUPPORTED', 20992: 'DRV_NOT_AVAILABLE',\r\n                  20115: 'DRV_ERROR_MAP', 20116: 'DRV_ERROR_UNMAP', 20117: 'DRV_ERROR_MDL', 20118: 'DRV_ERROR_UNMDL',\r\n                  20119: 'DRV_ERROR_BUFFSIZE', 20121: 'DRV_ERROR_NOHANDLE', 20130: 'DRV_GATING_NOT_AVAILABLE',\r\n                  20131: 'DRV_FPGA_VOLTAGE_ERROR', 20099: 'DRV_BINNING_ERROR', 20100: 'DRV_INVALID_AMPLIFIER',\r\n                  20101: 'DRV_INVALID_COUNTCONVERT_MODE'}\r\n        if code not in errors and user_def == '':\r\n            return f\"Wrong code number {code}\"\r\n        elif user_def != '':\r\n            return user_def\r\n        else:\r\n            if code != 0:\r\n                return errors[code]\r\n            else:\r\n                return user_def\r\n\r\nif __name__ == \"__main__\":\r\n    # DS_ANDOR_CCD.run_server()\r\n    a = Andor_test()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DeviceServers/ANDOR_CCD/DS_ANDOR_CCD.py b/DeviceServers/ANDOR_CCD/DS_ANDOR_CCD.py
--- a/DeviceServers/ANDOR_CCD/DS_ANDOR_CCD.py	(revision 10c0b59783286c06f8b8b081886d20398573f89c)
+++ b/DeviceServers/ANDOR_CCD/DS_ANDOR_CCD.py	(date 1643033937534)
@@ -371,12 +371,18 @@
 class Andor_test():
 
     def __init__(self):
+        self.n_ad_channels = None
+        self.n_amp = None
+        self.serial_number_real = None
+
+
         from pathlib import Path
         self.dll_path = Path('C:/dev/pyconlyse/DeviceServers/ANDOR_CCD/atmcd32d.dll')
         self.dll = self.load_dll()
 
         self._Initialize()
-        func = [self._GetCameraSerialNumber(), self._SetAcquisitionMode(3), self._SetExposureTime(0.0001)]
+        func = [self._GetCameraSerialNumber(), self._GetNumberADChannels(), self._GetNumberAmp(),
+                self._SetAcquisitionMode(3), self._SetExposureTime(0.0001), self._SetHSSpeed(0, 1)]
 
         results = []
 
@@ -385,7 +391,7 @@
 
         print(results)
 
-
+        self._ShutDown()
 
 
     """
@@ -414,11 +420,27 @@
         res = self.dll.Initialize(dir_char)
         return True if res == 20002 else self._error(res)
 
-    def _GetCameraSerialNumber(self) -> Tuple[int, bool, str]:
+    def _GetCameraSerialNumber(self) -> Tuple[bool, str]:
         serial_number = ctypes.c_int(0)
         res = self.dll.GetCameraSerialNumber(ctypes.byref(serial_number))
-        serial_number = serial_number.value
-        return serial_number if res == 20002 else self._error(res)
+        self.serial_number_real = serial_number.value
+        return True if res == 20002 else self._error(res)
+
+
+    def _GetNumberADChannels(self) -> Tuple[bool, str]:
+        n_adchannels= ctypes.c_int(0)
+        res = self.dll.GetNumberADChannels(ctypes.byref(n_adchannels))
+        self.n_ad_channels = n_adchannels.value
+        return True if res == 20002 else self._error(res)
+
+    def _GetNumberAmp(self) -> Tuple[bool, str]:
+        n_amp = ctypes.c_int(0)
+        res = self.dll.GetNumberAmp(ctypes.byref(n_amp))
+        self.n_amp = n_amp.value
+        return True if res == 20002 else self._error(res)
+
+    def _GetNumberHSSpeeds(self, channel: int, typ: int, speeds):
+        pass
 
     def _SetAcquisitionMode(self, mode: int) -> Tuple[int, bool, str]:
         """
@@ -446,6 +468,10 @@
         index = ctypes.c_int(index)
         res = self.dll.SetHSSpeed(typ, index)
         return True if res == 20002 else self._error(res)
+
+    def _ShutDown(self):
+        res = self.dll.ShutDown()
+        return True if res == 20002 else self._error(res)
 
     def _error(self, code: int, user_def='') -> str:
         """
@@ -491,6 +517,8 @@
             else:
                 return user_def
 
+
+
 if __name__ == "__main__":
     # DS_ANDOR_CCD.run_server()
-    a = Andor_test()
\ No newline at end of file
+    Andor_test()
\ No newline at end of file
